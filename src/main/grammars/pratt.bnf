{
  parserClass="org.intellij.grammar.expression.ExpressionParser"
  extends(".*expr")=expr
  elementTypeFactory="org.intellij.grammar.expression.ExpressionParserDefinition.createType"
  tokenTypeFactory="org.intellij.grammar.expression.ExpressionParserDefinition.createTokenType"
  elementTypeHolderClass="org.intellij.grammar.expression.ExpressionTypes"
  parserUtilClass="org.intellij.grammar.parser.GeneratedParserUtilBase"

  tokens=[
    space='regexp:\s+'
    comment='regexp://.*'
    number='regexp:\d+(\.\d*)?'
    identifier='regexp:\p{Alpha}\w*'
    string="regexp:('([^'\\]|\\.)*'|\"([^\"\\]|\\.)*\")"
    keke='keke'

    syntax='regexp:;|\.|\+|-|\*\*|\*|==|=|/|,|\(|\)|\^|\!=|\!|>=|<=|>|<'
  ]
}
root ::= (smth) *
//private element ::= expr ';'?  {recoverWhile=element_recover}
//private element_recover ::= !('(' | '+' | '-' | '!' | 'multiply' | id | number)

// left recursion and empty PSI children define expression root
expr ::= assign_expr
  | conditional_group
  | add_group


private conditional_group ::= elvis_expr | conditional_expr
private add_group ::= plus_expr | minus_expr

// expressions: auto-operator detection or parens
assign_expr ::= expr '=' expr { rightAssociative=true }
conditional_expr ::= expr ('<' | '>' | '<=' | '>=' | '==' | '!=') expr
minus_expr ::= expr '-' expr
plus_expr ::= expr '+' expr
elvis_expr ::= expr '?' expr ':' expr

//// test specific expressions
//external special_expr ::= meta_special_expr
//meta_special_expr ::= 'multiply' '(' simple_ref_expr ',' mul_expr ')' {elementType="special_expr" pin=2}

smth ::= Fdsfs | expr